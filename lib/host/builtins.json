{
    "#bitmask":    "IDL=1 bitmask -- Return a bitmask of all the bit indices\n INT...     :: with() Math.bits( ...$1 )",
    "#cat":        "IDL=1 cat     -- Copy FILE to stdout                    \n (FILE|URL) :: with() await fetch($1).buffer() as Buffer",
    "./../formatOutput.mjs#csv":  "IDL=1 OUTPUT_MIMETYPE=\"text/csv\" csv -- Output a JSON table as CSV.\n [--input=JSON_FILE] :: with( toCSV,fromObjectArray ) toCSV( fromObjectArray( input.toJSON() ), { eol: EOL }  )", 
    "./../formatOutput.mjs#psv":  "IDL=1 psv -- Output a JSON table as pipe-separated variables - suitable for use as a markdown table\n [--input=JSON_FILE] :: with( toMarkdown,fromObjectArray ) toMarkdown( fromObjectArray( input.toJSON() ), { eol: EOL }  )", 
    "#echo":       "IDL=1 echo TEXT... :: with() TEXT.join(' ') as String",
    "#echo-value":  "IDL=1 -- Echo an option value instead of a positional. (For testing.)\n echo-value --value=TEXT :: with() value as String",
    "#echo1":       "IDL=1 -- Single argument version of echo. (Because lists can't contain expression.)\necho1 TEXT :: with() $1 as String",
    "#echo-json":   "IDL=1 -- Used for testing: output the JSON\nOUTPUT_FORMAT=JSON0 echo-json JSON :: with() $1",
    "#get":      [
        "IDL=1", 
        "-- Fetch VAR_NAME from the lexical environemnt. For example `get cwd` or `get --output-format=JSON EOL`",
        "get VAR_NAME :: with() $LEXICAL_ENVIRONMENT$.get(VAR_NAME)" 
    ],
    "./builtins/log.mjs": "*", 
    "#product":  "IDL=1 product -- Product of all the numbers.            \n INT...     :: with() Math.product( ...$1 )", 
    "#split":    "IDL=1 split -- Split text into chunks.              \n [--limit=COUNT] SPLIT_STRING TEXT :: with() $2.split( $1, limit ?? undefined)",
    "#shuffle":  [
        "IDL=1",
        "shuffle           -- Randomise the order of a set of strings.", 
        "   [--seed=COUNT] -- The number seed. If ommitted, a random number will be picked.",
        "   STRING...", 
        ":: with( )",
        "    ( seed ?? Math.random32() )",
        "    |> $1.map( text => ({text,hash:text.hash( % )}) )",
        "    |> %.toSorted( ( a, b ) => Math.diff( a.hash, b.hash ) )",
        "    |> %.map( a => a.text )"
    ],
    "#avg":      "IDL=1 avg     -- Average of the list of numbers         \n [INT...]     :: with() Math.quotient( Math.sum( ...$1 ), $1.length )", 
    "#sum":      "IDL=1 sum     -- Sum all the numbers.                   \n INT...     :: with() Math.sum( ...$1 )", 
    "./help.mjs":              "IDL=1 help    [SCRIPTLET] :: default($1.idl ?? null,{SCREEN_COLUMNS,externalName:$1.name ?? 'help'})",
    "--node:fs#cp":            "IDL=1 cp      -- This is the 'cp' implementation in 'node:fs'. (Which means certain behaviours break the js-hell conventions.)\n[(-R|--recurse)] SOURCE_NAME DEST_NAME :: cpSync( $1, $2, { recursive: recurse ?? false })",
    "node:fs#cp":              "IDL=1 cp      -- Reserved for future use.\n :: with() new Error( 'reserved for future use.' )",
    "./builtins/call.mjs": "*",
    "./builtins/dir.mjs": "*",
    "./builtins/findstr.mjs": "*",
    "#false": "IDL=1 false :: with () false",
    "./builtins/get-exports.mjs": "*",
    "#json": [
        "IDL=1",
        "-- Parse a JSON file and output it _as_ JSON.",
        "-- ",
        "-- For example `json somefile.json --output-format=psv` will turn it into a markdown table.",
        "json JSON_FILE :: with( ) $1.toJSON() as JSON"
    ],
    "./builtins/json-set.mjs": "*",
    "./builtins/rand.mjs": "*",
    "#resolve": [
        "IDL=1",  
        "resolve     -- Run the scriplet resolver on SCRIPTLET and return the URL of the ESM module that will be used.",  
        "    [--idl] -- Return the IDL instead of the MODULE_URL.",  
        "     SCRIPTLET",  
        "     :: with() $1[idl ? 'idl' : 'moduleUrl'].toString()"
    ],
    "./builtins/select.mjs": "*",
    "#spawn": "IDL=1 spawn -- Reserved for future use.\n:: with() new Error( 'Reserved for future use.')",
    "#true": "IDL=1 true :: with () true",
    "./builtins/template.mjs": "*", 
    "#zeroes": "IDL=1 zeroes [BYTE_COUNT] :: with() Buffer.alloc( $1 = 0 ) as Buffer",
    "./getProjectdir.mjs#get-projectdir": [
        "IDL=1",
        "-- Move up through the directory tree and return the first directory conaining FILE_NAME.",
        "-- ",
        "-- ### Example",
        "-- ```",
        "-- js-hell get-projectdir package.json",
        "-- ```",
        "get-projectdir",
        "     [--relative] -- Return a relative path, instead of an absolute one.", 
        "     FILE_NAME ",
        ":: default($fileName,cwd.toString(),{relative=false}) as Dirname"
        
    ],
    "--": "Note the hack to get out of this. Should be illegal, but we need to exempt ourself, if that's the case.",
    "./../args/argtok.mjs": [
        "IDL=1",
        "-- Split STRING into individual arguments using js-hell's internal tokeniser.",
        "-- (This can be useful for seeing how js-hell is interpreting arguments or will call",
        "-- an external command.)",
        "--",
        "-- Arguments are separated by spaces (any codepoint matching /\\s/)",
        "-- and by the specials `!?$%^=@#~()[]{}<>&|,;`'\"`.", 
        "--",
        "-- Empty strings, and strings containing spaces or special characters can be quoted",
        "-- with single or double quotes (\"\" or '').",
        "--",
        "-- There in no escaping: quotes run through to next occurence of the quote character.", 
        "-- (This means you can't use strings that contain both `\"` and `'`. It's for Windows",
        "-- filenames - the plan is to add `` quoting with escaping.)",
        "--",
        "-- Quotes can only happen at the start of a token (or the start of an option's",
        "-- value). So `some\" \"thing` is NOT permitted - it has to be `\"some thing\"`. (But",
        "-- `--char=\" \"` is fine to specify a space.)", 
        "",
        "argtok STRING :: shfy($string) as JSON"
      ],
    "./../types/registry.mjs#idl-types": [ "IDL=1",
        "-- List the names and aliases in the type registry",
        "idl-types :: list()" 
    ],
    "#repl": "IDL=1 repl -- Reserved for future use.\n:: with() new Error( 'Reserved for future use.' )",
    "#rm":   "IDL=1 rm -- Reserved for future use.\n:: with() new Error( 'Reserved for future use.' )",
    "#run":  "IDL=1 run -- Reserved for future use.\n:: with() new Error( 'Reserved for future use.' )",
    "node:crypto#uuid": "IDL=1 uuid -- Output a random UUID (i.e. wraps `crypto.getRandomUUID()`)\n:: randomUUID()",
    "./../webhost/server.mjs#xwh": "*",
    "./version.mjs": "*",
    "./version.mjs#ver": "*"
}